### 题目汇总
1. 
    <details><summary>讲讲static关键字
    </summary>
    1. 函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；  <br/>
    2. 在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；  <br/>
    3. 在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；<br/>
    4. 在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；<br/>
    5. 在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的static 成员变量。<br/>
    </details>

2. 
    <details><summary>const关键字有什么用
    </summary>
    1. 欲阻止一个变量被改变，可以使用 const 关键字。在定义该 const 变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；<br/>
    2. 对指针来说，可以指定指针本身为 const，也可以指定指针所指的数据为 const，或二者同时指定为 const；<br/>
    3. 在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；<br/>
    4. 对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的 成员变量；<br/>
    5. 对于类的成员函数，有时候必须指定其返回值为 const 类型，以使得其返回值不为"左值"<br/>
    </details>

3. 
    <details><summary>指针和引用的区别
    </summary>
    1. 引用不可为空，指针可为空 <br/>
    2. 引用一旦初始化不可改变指向，指针可以 <br/>
    3. 引用比指针更安全。由于不存在空引用，并且引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用，因此引用很安全。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为 NULL，所以不安全。const 针虽然不能改变指向，但仍然存在空指针，并且有可能产生野指针（即多个指针指向一块内存，free 掉一个指针之后，别的指针就成了野指针）。 <br/>
    </details>

4. 
    <details><summary>在什么情况下应该使用dynamic_cast替代虚函数？</summary> 

    通常是基类设计出现问题，无法改动基类源码，又想要在派生类中添加新的成员函数，此时使用基类指针无法调用这个新的非虚函数，那就需要用dynamic_cast来进行动态类型转换从而调用到派生类的非虚函数。 
    </details>
   
5. 
    <details><summary>什么是虚函数？有什么用 
    </summary>
     一个虚函数被调用时，被执行的代码必须和调用函数的对象的动态类型相一致。虚函数是用来实现C++的动态多态的 
     </details>
6. 
    <details><summary>虚函数的实现原理 
    </summary> 
    虚函数表，虚函数指针;<br/> 
    每一个声明了虚函数或继承了虚函数的类，都会有一个自己的虚函数指针表(virtual table,vtbl) <br/> 该类的每个对象都会包含一个虚函数表指针(virtual pointer, vptr)指向vtbl，虚函数按其声明顺序放进vtbl中，vtbl中的每个元素对应一个函数指针指向该类的虚函数；如果派生类覆盖了基类的虚函数，就会放到vtbl中原来基类函数的位置。在多继承情况下每个基类都有自己的vtbl，派生类的成员函数被放到第一个基类的vtbl中 
    </details>

7. 
    <details><summary>虚函数可以是内联函数吗
    </summary>
    可以，但是当虚函数表现多态性的时候不能内联<br/>
    因为内联是建议编译器内联，而虚函数是运行时多态，编译器在编译期间无法得知运行期调用的是哪一段代码，所以运行时多态的虚函数不允许内联 <br/>

    </details>

8. 
    <details><summary>delete this合法吗？
    </summary>
    合法，但需要注意：<br/>
    1. 必须保证this对象时通过new（不是new[], placement new,不是栈上，不是全局，不是其他对象成员）分配的 <br/>
    2. 必须保证调用delete this的成员函数时最后一个调用this的成员 <br/>
    3. 必须保证成员函数的delete this后面没有调用this <br/>
    4. 必须保证delete this后面不会再被调用 <br/>
    </details>

9. 
    <details><summary>如何定义一个只能在堆上/栈上生成对象的类？
    </summary>
    1. 只在堆上 : <br/>
    方法：将析构函数设置为私有 <br/>
    原因：c++时静态绑定语言，编译器管理栈上对象的生命周期，编译器在为对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象 <br/>
    2. 只在栈上 : <br/>
    方法：将new和delete重载为私有 <br/>
    原因：只有使用new关键词新建对象才会在堆上生成，将new私有化则无法在堆上生成对象
    </details>

10. 
    <details><summary>说说引用传递、值传递和引用传递
    </summary>
    1. 指针传递：传递的是一个地址值 <br/>
    2. 值传递：在栈中开辟内存空间以存放由主调函数传入的实参的值，从而成为实参的一个副本。值传递的特点在于无论对其作何种操作，都不会影响到主调函数中实参变量的值 <br/>
    3. 引用传递：与值传递不同的是，这次在栈中开辟的空间存放的不是实参的值，而是实参变量的地址。被调函数对形参的任何操作都会被处理成间接寻址，通过形参中存放的地址直接对主调函数中的实参变量进行操作 <br/>
    </details>

11. 
    <details><summary>深拷贝和浅拷贝
    </summary>
    1. 浅拷贝：<br/>
    对一个指定对象进行拷贝时，编译器会自动调用默认的拷贝构造函数（用户为重载的情况下）；两个对象只调用一次构造函数，但每个对象销毁时都会调用一次析构函数，也就是说只有一次构造却出现了两次析构，此时两个对象的指针成员所指向的内存相同，同一块内存被释放了两次，会出现内存泄漏 <br/>
    2. 深拷贝 <br/>
    在对含有指针成员的对象进行拷贝时，必须要自己定义拷贝构造函数，使拷贝后的对象指针成员有自己的内存空间，即进行深拷贝，这样就避免了内存泄漏发生，用一次构造函数，一次自定义拷贝构造函数，两次析构函数。两个对象的指针成员所指内存不同。 <br/>
    总结：浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。<br/>
    </details>

