### C ---- C++ 部分特性添加/升级
#### 命名空间
- 作用：防止命名冲突（如多人协作开发）
- 注意：可嵌套定义， 命名空间冲突时会进行合并
- C在这一问题的处理上使用了static关键字控制变量/函数的存储域
- **命名空间内只能声明函数，不能定义**

#### const
- 在C中，const会将被修饰变量变为只读变量（不可直接修改，但可间接修改）
- 在C++中，编译器严格检查const的对等性，这一特性使const修饰的变量可以直接被当作常量（因为无法使用非const指针来间接修改被修饰变量）
- 修饰函数形参：保护实参不被在函数执行过程中修改  (函数接口的安全性)
- 修饰成员函数：该成员函数只能访问成员变量，不能修改；
- mutable用于声明变量，被其修饰的变量可以被const修饰的函数修改；
- const修饰对象：该对象为常对象，只能访问const成员；(定义并初始化:类必须含有有参构造函数)

#### constexpr
- 用于修饰函数，较之C中的define更安全
- 该关键字用于定义常量表达式，在编译时进行替换，省去了运行时的函数调用、传参、执行、释放等操作，可提高运行效率

#### 函数重载
- 规则：参数个数不通，参数类型不通，参数顺序不同（全部命中即一个重载函数）
- 注：**默认参数会影响重载条件**

#### 引用
- 对一个变量起别名，对其引用做操作就相当于对其本身做操作（这一特性类似于指针，但引用更方便，无需考虑地址和值的问题，因为她只是一个别名）
- **引用是占内存的，相当于一个定义时即绑定初始化地址的指针，且其存储于系统级空间，用户/程序无权操作**
- C++11起提出了右值引用，表示不可写且不可取地址的变量的引用（常用于移动构造函数），自此引用不再只有一级
- 高效编程，是引用这一概念提出的原因；有了引用后，程序员不再需要纠结于传值还是传地址的问题，只要需要修改传入变量，就可以传入该变量的引用；
- 引用的另一个优点：效率高，相较于传值，省去了形参的复制操作，开销更小，大多数情况下直接传引用即可

#### string
- c++中的字符串容器，包含一系列字符串操作，对比于C中的char *，其拥有动态的存储容量与更多的字符串操作，自由度与易用程度更高了
- 因为是容器，所以支持所有迭代器的泛型算法（存在于< algorithm >中）
- **string的可变长设计**，基本类似于java中ArrayList的动态分配机制，每当长度等于容量时，扩容1.5倍/2倍（具体扩容策略不同，结果也不同）
- **千万要注意的一点是**，若有一个指向string对象的指针/引用/迭代器，则在string对象**大小改变后**可能**失效**，因为若string所在内存块的剩余大小不够扩容，则其起始地址会发生变化，之前的所有指针/引用/迭代器都会失效；
- string在初始化时会有默认预留空间，通常为15字节；可以用reserve改变预留空间的大小(但不可小于默认大小)，若赋值后发现预留空间过大，可调用shrink_to_fit方法进行缩容，缩容后的容量等于该字符串的长度
- 访问方式支持下标访问和at()访问，前者边界不安全但开销更小（无需调用函数，省去很多相关开销）

#### 类--结构体
- C++引入类是为了解决变量的访问权限问题；通常在使用一个C库时会碰到的问题就是，函数太多，让用户无从下手，而 C+\+引入这一概念后，类设计者可以将辅助函数进行私有化，使其对用户不可见（C中同样可以使用static来解决可见性问题）
- 在C++中类与结构体的唯一区别就在于其默认权限不同，类的默认权限是私有的，结构体相反
- class的默认继承方式为private,struct的默认继承为public

#### 类--对象
- 对象即实例化后的类， 每个对象的成员变量存储与其独占的存储空间，所有同类对象共享方法代码段
- **当某一成员变量被static修饰后，其也会被置于共享空间内**
- **当某一成员函数被static修饰后，同样属于类，所以不会在调用时传入this指针(不存在所属对象)**
- 未被static修饰的成员方法在调用时会被重构，形参中会出现其所有者的指针this
- 访问形式：对象.静态成员  ------ 类名::静态成员（不用实例化）
- 注：static修饰的成员必须在类外初始化
- static修饰成员函数/变量的使用场景：通常是在用C接口时，使函数对外可用

#### 强制类型转换
- static_cast	:相关类型，void*--->任意指针, 父类与子类
- const_cast	:去除指针/引用的const	(用到的情况下通常需要考虑整体的设计问题)
- reinterpret_cast:任意指针之间的类型转换 **(不同于static_cast, 它是任意指针之间.static_cast是任意与void *之间)**
- dynamic_cast	: RTTI(run time type info)多态

#### 构造函数
- C++中用构造函数来代替初始化函数，优点在于对象实例化时可以自动调用，避免了程序员忘记初始化导致的错误；**缺点：调用时机固定**
- 构造函数可以使用初始化列表，对于一些诸如 const、引用、无默认构造函数 的成员对象的需要同时定义且初始化的成员，需要用初始化列表进行初始化;**优先使用初始化列表，效率高**
- 构造函数共有5中，分别是
	- 有参构造函数
	- 无参构造函数
	- 类型转换（记得用explicit防止隐式类型转换）
	- 拷贝构造函数（最好自定义，默认使用浅拷贝**可能导致二次释放**）
	- 移动构造函数（移动后，原对象的成员指针必须置空，否则指向地址相同，仍会导致二次释放），要注意的一点是，对于g++来说匿名临时对象不会调用移动构造函数/移动赋值运算符；而对于vs的msvc，会自动调用移动构造函数/移动赋值运算符
- 其中，移动构造函数常声明为 Foo(Foo &&foo)；，这种构造函数用于将临时对象直接改名为新对象，减少了将临时对象拷贝到新对象时的多余开销，直接将临时对象改名为了新对象
- 若要调用移动构造函数，需要在传参时用std::move函数将参数转换为右值引用

#### 类成员变量/函数指针
- **使用前必须实例化一个对象**
- 类成员函数指针比较常用，一般用于隐藏调用接口
- 成员变量指针中存储的并非地址而是偏移量（相对于第一个成员变量而言）

#### 友元
- 使用friend声明
- 使普通函数/其他类可以访问 类内的私有成员
- 三种友元
    - 友元成员函数（注：**g++中，必须类外定义**）
    - 友元类
    - 友元函数
- 使用友元会破坏类的封装性
- 注：**友元类不能传递/继承**

#### 继承
- 三种继承：
    - public，所有成员的权限不变，完全拷贝
    - protected，除private成员外，都变为对外私有，对内公开
    - private，与protected相同
    - **补充：protected和private的区别就在于继承时，protected仍保持派生类中的可见性，private对于派生类不可见，其余部分完全相同**
    - 用public即可
- 无论是何种继承，基类的private成员对于派生类来说都是无法访问的
- **注意，无论派生类能否访问，所有基类的成员都会被拷贝到派生类中，派生类的所占空间 = 派生类自身成员空间 + 基类成员空间**
- 派生类对象中，**含有与其基类对应的组成部分**，这也是为什么可以把**派生类对象/其引用/指针用在需要对应基类对象/其指针/引用的地方**
- **注意：默认的向上类型转型只拷贝成员变量，不会改变代码段（在只有继承的情况下，向上类型转换无意义）**
- 不存在基类向派生类的类型转换，因为基类可以是派生类的一部分，也可以独立存在；（所谓的基类向派生类转换是指，用派生类引用/指针来接基类对象/对象地址）
- 继承来的基类成员仍然由基类来初始化，每个类只管自己的成员初始化
- final用于防止继承

### 当继承体系中出现静态成员
- 该静态成员将贯穿自出现静态成员的基类之后的整个继承体系，无论出现多少派生类，始终只有一个唯一实例
- 若该成员本身可访问（非private），则可通过基类或派生类来访问

#### virtual关键字
- 修饰成员函数时，将其声明为**虚函数**：
    - 通常被用于定义那些需要派生类自己进行修改以适配自身的函数；
    - 派生类必须在其内部对所有重新定义的虚函数进行声明；
    - C++11允许派生类使用override关键字显式注明将使用哪个成员函数改写基类的虚函数；（若定义与基类同名同参的函数，则会隐式覆盖）使用override的好处是，一旦编译器会帮助检查当前定义的函数与基类中的虚函数是否形参一致，防止意外产生；
    - 任何构造函数之外的非静态函数都可以是虚函数（虚函数属性可继承）
    - 虚函数与普通函数的解析时间不同：一个普通函数通常会在编译时被解析，因为其对可能出现的派生类的实现并不关心；而一个虚函数会在运行时解析，因为其必须适应派生类
- 修饰继承列表时，表示**虚继承**
    - 常用于解决多重继承的二义性；

#### 静态类型 --- 动态类型
- 静态类型：即声明时给定的类型，通常在编译时已知
- 动态类型：即表达式或变量所绑定的内存中的对象的类型，通常在运行时才能得知
- 基类的指针或引用的动态类型和其静态类型可能不同，因为存在派生类向基类的隐式类型转换（因为派生类中包含基类的一部分，所以可以做类型转换，具体见++继承++部分）
- 动态绑定只有在通过指针/引用调用虚函数时才会发生

#### 虚函数指针与虚函数指针表
- 一个类但凡有一个虚函数声明，则其实例都会包含一个虚函数指针表，表中存储的指针分别指向各个虚函数
