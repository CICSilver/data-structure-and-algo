### C ---- C++ 部分特性添加/升级
#### 命名空间
- 作用：防止命名冲突（如多人协作开发）
- 注意：可嵌套定义， 命名空间冲突时会进行合并
- C在这一问题的处理上使用了static关键字控制变量/函数的存储域
- **命名空间内只能声明函数，不能定义**

#### const
- 在C中，const会将被修饰变量变为只读变量（不可直接修改，但可间接修改）
- 在C++中，编译器严格检查const的对等性，这一特性使const修饰的变量可以直接被当作常量（因为无法使用非const指针来间接修改被修饰变量）
- 修饰函数形参：保护实参不被在函数执行过程中修改  (函数接口的安全性)
- 修饰成员函数：该成员函数只能访问成员变量，不能修改；
- mutable用于声明变量，被其修饰的变量可以被const修饰的函数修改；
- const修饰对象：该对象为常对象，只能访问const成员；(定义并初始化:类必须含有有参构造函数)

#### constexpr
- 用于修饰函数，较之C中的define更安全
- 该关键字用于定义常量表达式，在编译时进行替换，省去了运行时的函数调用、传参、执行、释放等操作，可提高运行效率
- 用于定义构造函数时，指定该类为字面类（被修饰的构造函数通常函数体为空，因为constexpr要求必须有返回值，而构造函数不存在return语句）

#### 函数重载
- 规则：参数个数不通，参数类型不通，参数顺序不同（全部命中即一个重载函数）
- 注：**默认参数会影响重载条件**

#### inline
- 相当于把内联函数里面的内容直接写在调用内联函数处
- 相当于不用执行进入函数的步骤，直接执行函数体
- 相当于宏，但是具有类型检查，具有函数特性
- 这只是个对编译器的建议，当函数体中出现如**循环、递归、switch**等复杂操作时，编译器会拒绝内联
- 除虚函数外，在类中定义的函数会隐式地当成内联函数
- 编译器地处理步骤：
    1. 将inline函数体复制到inline函数调用点处
    2. 为所用inline函数中地**局部变量分配内存空间**
    3. 将inline函数地输入参数和返回值**映射到调用方法地局部变量**空间中
    4. 若inline函数有**多个返回点**，则用**goto语句**将其转变为inline函数代码块末尾地分支
- 优缺点：
    - 优点：
        - 内联函数和宏函数一样在被调用处进行代码展开，省去了**参数压栈、栈帧开辟与回收、结果返回**等开销，从而提高了程序的运行速度
        - 内联函数在代码展开时会做**安全检查**或**自动类型转换**， 比宏函数更安全
        - 类中定义地隐式内联函数可以访问类地成员变量，宏函数不能
        - 内联函数在运行时可调试，宏定义不可以
    - 缺点：
        - **代码膨胀**，内联做的其实就是复制粘贴，用于消除函数调用带来地一系列开销。如果执行函数体内代码地时间远大于函数调用地开销，那这么做只会适得其反；另一方面，每个使用内联函数地地方都会引起复制代码，这将使程序地总代码量增大，从而消耗更多的内存空间；
        - inline函数无法随函数库升级而升级，因为inline函数的改变需要重新编译，不像non-inline可以直接链接
        - 是否内联，是不可控的；

#### union（联合）
- 一种节省空间的特殊类，一个union可以有多个数据成员，但是任意时刻只有一个数据成员可以有值。当某个成员被赋值后，其他成员变为未定义状态；
- 特点：
    1. 默认访问控制符为public
    2. 可以有构造/析构函数
    3. 不能含有引用类型成员
    4. 不能继承自其他类，不能作为基类
    5. 不能含有虚函数
    6. 匿名union在定义所在作用域可直接访问union成员
    7. 匿名union不能包含protected成员或private成员
    8. 全局匿名union必须为静态


#### 引用
- 对一个变量起别名，对其引用做操作就相当于对其本身做操作（这一特性类似于指针，但引用更方便，无需考虑地址和值的问题，因为她只是一个别名）
- **引用是占内存的，相当于一个定义时即绑定初始化地址的指针，且其存储于系统级空间，用户/程序无权操作**
- C++11起提出了右值引用，表示不可写且不可取地址的变量的引用（常用于移动构造函数），自此引用不再只有一级
- 高效编程，是引用这一概念提出的原因；有了引用后，程序员不再需要纠结于传值还是传地址的问题，只要需要修改传入变量，就可以传入该变量的引用；
- 引用的另一个优点：效率高，相较于传值，省去了形参的复制操作，开销更小，大多数情况下直接传引用即可

#### 引用折叠
- X& &，X& &&，X&& &可折叠成 X&
- X&& && 可折叠成 X&&

#### string
- c++中的字符串容器，包含一系列字符串操作，对比于C中的char *，其拥有动态的存储容量与更多的字符串操作，自由度与易用程度更高了
- 因为是容器，所以支持所有迭代器的泛型算法（存在于< algorithm >中）
- **string的可变长设计**，基本类似于java中ArrayList的动态分配机制，每当长度等于容量时，扩容1.5倍/2倍（具体扩容策略不同，结果也不同）
- **千万要注意的一点是**，若有一个指向string对象的指针/引用/迭代器，则在string对象**大小改变后**可能**失效**，因为若string所在内存块的剩余大小不够扩容，则其起始地址会发生变化，之前的所有指针/引用/迭代器都会失效；
- string在初始化时会有默认预留空间，通常为15字节；可以用reserve改变预留空间的大小(但不可小于默认大小)，若赋值后发现预留空间过大，可调用shrink_to_fit方法进行缩容，缩容后的容量等于该字符串的长度
- 访问方式支持下标访问和at()访问，前者边界不安全但开销更小（无需调用函数，省去很多相关开销）

#### 面向对象
- 三大特征：封装、继承、多态
- 封装：类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏（使用访问控制符实现）
- 多态：
    1. 重载多态（编译期/早绑定，又叫静态多态）：函数重载、运算符重载
    2. 子类型多态（运行期/晚绑定，又叫动态多态）：虚函数
    3. 参数多态性（编译期）：类模板、函数模板
    4. 强制多态（编译期/运行期）：基本类型转换、自定义类型转换


#### 类--结构体
- C++引入类是为了解决变量的访问权限问题；通常在使用一个C库时会碰到的问题就是，函数太多，让用户无从下手，而 C+\+引入这一概念后，类设计者可以将辅助函数进行私有化，使其对用户不可见（C中同样可以使用static来解决可见性问题）
- 在C++中类与结构体的唯一区别就在于其默认权限不同，类的默认权限是私有的，结构体相反
- class的默认继承方式为private,struct的默认继承为public

#### 类--对象
- 对象即实例化后的类， 每个对象的成员变量存储与其独占的存储空间，所有同类对象共享方法代码段
- **当某一成员变量被static修饰后，其也会被置于共享空间内**
- **当某一成员函数被static修饰后，同样属于类，所以不会在调用时传入this指针(不存在所属对象)**
- 未被static修饰的成员方法在调用时会被重构，形参中会出现其所有者的指针this
- 访问形式：对象.静态成员  ------ 类名::静态成员（不用实例化）
- 注：static修饰的成员必须在类外初始化
- static修饰成员函数/变量的使用场景：通常是在用C接口时，使函数对外可用

#### 强制类型转换
- static_cast	:相关类型，void*--->任意指针, 父类与子类
- const_cast	:去除指针/引用的const	(用到的情况下通常需要考虑整体的设计问题)
- reinterpret_cast:任意指针之间的类型转换 **(不同于static_cast, 它是任意指针之间.static_cast是任意与void *之间)**
- dynamic_cast	: RTTI(run time type info)多态

#### 构造函数
- C++中用构造函数来代替初始化函数，优点在于对象实例化时可以自动调用，避免了程序员忘记初始化导致的错误；**缺点：调用时机固定**
- 构造函数可以使用初始化列表，对于一些诸如 const、引用、无默认构造函数 的成员对象的需要同时定义且初始化的成员，需要用初始化列表进行初始化;**优先使用初始化列表，效率高**
- 派生类能够重用基类定义的构造函数
```c++
class Derived : Base
{
public:
    using Base::Base;
}
```
- 构造函数共有5中，分别是
	- 有参构造函数
	- 无参构造函数
	- 类型转换（记得用explicit防止隐式类型转换）
	- 拷贝构造函数（最好自定义，默认使用浅拷贝**可能导致二次释放**）
	- 移动构造函数（移动后，原对象的成员指针必须置空，否则指向地址相同，仍会导致二次释放），要注意的一点是，对于g++来说匿名临时对象不会调用移动构造函数/移动赋值运算符；而对于vs的msvc，会自动调用移动构造函数/移动赋值运算符
- 其中，移动构造函数常声明为 Foo(Foo &&foo)；，这种构造函数用于将临时对象直接改名为新对象，减少了将临时对象拷贝到新对象时的多余开销，直接将临时对象改名为了新对象
- 若要调用移动构造函数，需要在传参时用std::move函数将参数转换为右值引用

#### 类成员变量/函数指针
- **使用前必须实例化一个对象**
- 类成员函数指针比较常用，一般用于隐藏调用接口
- 成员变量指针中存储的并非地址而是偏移量（相对于第一个成员变量而言）

#### 友元
- 使用friend声明
- 使普通函数/其他类可以访问 类内的私有成员
- 三种友元
    - 友元成员函数（注：**g++中，必须类外定义**）
    - 友元类
    - 友元函数
- 使用友元会破坏类的封装性
- 注：**友元类不能传递/继承**

#### 继承
- 三种继承：
    - public，所有成员的权限不变，完全拷贝
    - protected，除private成员外，都变为对外私有，对内公开
    - private，与protected相同
    - **补充：protected和private的区别就在于继承时，protected仍保持派生类中的可见性，private对于派生类不可见，其余部分完全相同**
    - 用public即可
- 无论是何种继承，基类的private成员对于派生类来说都是无法访问的
- **注意，无论派生类能否访问，所有基类的成员都会被拷贝到派生类中，派生类的所占空间 = 派生类自身成员空间 + 基类成员空间**
- 派生类对象中，**含有与其基类对应的组成部分**，这也是为什么可以把**派生类对象/其引用/指针用在需要对应基类对象/其指针/引用的地方**
- **注意：默认的向上类型转型只拷贝成员变量，不会改变代码段（在只有继承的情况下，向上类型转换无意义）**
- 不存在基类向派生类的类型转换，因为基类可以是派生类的一部分，也可以独立存在；（所谓的基类向派生类转换是指，用派生类引用/指针来接基类对象/对象地址）
- 继承来的基类成员仍然由基类来初始化，每个类只管自己的成员初始化
- final用于防止继承

#### 智能指针
- C++11之后引入了shared_ptr、weaked_ptr和unique_ptr，删除了auto_ptr，scoped_ptr也已经过时
- shared_ptr是共享所有权的，可以被拷贝，其所指向的对象会在最后一个引用被销毁时释放
- weaked_ptr允许共享但不拥有某对象，一旦最后一个拥有该对象的智能指针失去所有权，weak_ptr都会被自动置空。因此，在default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。
    - 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在“被使用” 的状态）的问题
- unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独
    占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销
    毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被
    释放。(取代auto_ptr)
- auto_ptr和unique_ptr的比较：
    - auto_ptr可以赋值拷贝，赋值拷贝后所有权转移 <br/> unique_ptr无赋值拷贝，但实现了move
    - auto_ptr对象不能管理数组（析构调用delete而不是delete []）<br/> unique_ptr可以管理数组(析构调用delete [])



---

### 当继承体系中出现静态成员
- 该静态成员将贯穿自出现静态成员的基类之后的整个继承体系，无论出现多少派生类，始终只有一个唯一实例
- 若该成员本身可访问（非private），则可通过基类或派生类来访问

#### virtual关键字
- 修饰成员函数时，将其声明为**虚函数**：
    - 通常被用于定义那些需要派生类自己进行修改以适配自身的函数；
    - 派生类必须在其内部对所有重新定义的虚函数进行声明；
    - C++11允许派生类使用override关键字显式注明将使用哪个成员函数改写基类的虚函数；（若定义与基类同名同参的函数，则会隐式覆盖）使用override的好处是，一旦编译器会帮助检查当前定义的函数与基类中的虚函数是否形参一致，防止意外产生；
    - 任何构造函数之外的非静态函数都可以是虚函数（虚函数属性可继承）
    - 虚函数与普通函数的解析时间不同：一个普通函数通常会在编译时被解析，因为其对可能出现的派生类的实现并不关心；而一个虚函数会在运行时解析，因为其必须适应派生类
- 修饰继承列表时，表示**虚继承**
    - 常用于解决多重继承的二义性；

#### 静态类型 --- 动态类型
- 静态类型：即声明时给定的类型，通常在编译时已知
- 动态类型：即表达式或变量所绑定的内存中的对象的类型，通常在运行时才能得知
- 基类的指针或引用的动态类型和其静态类型可能不同，因为存在派生类向基类的隐式类型转换（因为派生类中包含基类的一部分，所以可以做类型转换，具体见++继承++部分）
- 动态绑定只有在通过指针/引用调用虚函数时才会发生

#### 虚继承 --- 虚函数
- 相同之处：都利用了虚指针（占用类的存储空间）和虚表（不占用类得存储空间）
- 不同之处：
    - 虚继承
        1. 虚基类依旧存在继承类中，只占用存储空间
        2. 虚基类表存储的是虚基类相对直接继承类的偏移
    - 虚函数
        1. 虚函数不占用存储空间
        2. 虚函数表存储的是虚函数地址

#### 虚函数指针与虚函数指针表
- 一个类但凡有一个虚函数声明，则其实例都会包含一个虚函数指针表，表中存储的指针分别指向各个虚函数

---

#### 内存分配和管理
- malloc : 申请指定字节数的内存，申请到的内存中的初始值不确定
- calloc : 为指定长度的对象，分配能容纳其指定个数的内存**并将申请到的内存初始化为0**
- realloc: 更改以前分配的内存长度，当增加长度时， 可能需要将之前内存中的内容移动到另一个足够大的区域，而新增区域内的初始值不确定（不会初始化新分配的内存区域）
- 以上三种分配的内存都在堆上，分配和释放由程序员自己控制（可能引起内存泄漏）
- alloca ： 在栈上申请内存，程序在出栈时自动释放内存。但是alloca不具备可移植性，而且在没有传统堆栈的机器上很难实现。alloca不适合出现在需要广泛移植的程序中。C99中支持变长数组(VLA)，可以用来替代alloca

#### new --- delete
- new/new[]:完成两件事，先底层调用malloc分配内存，然后调用构造函数
- delete/delete[]:一样完成两件事，先调用析构函数清理资源，然后底层调用free释放内存
- 需要注意的是，new在申请内存时会自动计算所需的字节数，而malloc则需要程序员自己指定申请内存空间的字节数
- 定位new（placement new）允许程序员向new传递额外的地址参数，从而在预先指定的内存区域创建对象
```c++
new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_address) type [size] {braced initializer list}
// 其中place_address是个指针
// initializers提供一个初始值列表（可以为空）
```

#### decltype
- 用于检查实体的声明类型或表达式的类型及值分类
- 语法：decltype (exoression)
- 应用：
```c++
template <typename It>
auto func(It beg, It end) -> decltype(*beg)
{
    /* ... */
    return *beg;    // 返回序列中一个元素的引用
}

template <typename It>
auto func2(It beg, It end) -> typename remove_reference<decltype(*beg)>::type
{
    /* ... */
    return *beg;    // 返回序列中一个元素的拷贝
}
```

#### 模板
- 显式实例化，C++11新特性，用于优化模板函数的跨文件重复声明

---
### STL

| 容器 | 底层数据结构 | 时间复杂度 | 有无序 | 可否重复 | 其他 |
|--------|--------|--------|--------|--------|--------|
| array | 数组 | 随机读写O(1) | 无序| 可重复 | 支持快速随机访问 |
| vector | 数组 | 随机读写、尾部插入、尾部删除，O(1) <br/> 头部插入、头部删除，O(n) | 无序 | 可重复 | 支持快速随机访问 |
| list | 双向链表 | 插入、删除O(1) <br/>随机读写O(n) | 无序 | 可重复 | 支持快速增删 |
| deque | 双端队列 | 头尾插入/删除，O(1) | 无序 | 可重复 | 一个中央控制器+多个缓冲区，支持头尾快速增删，支持随机访问 |
| stack | deque/list | 顶部插入/删除O(1) | 无序 | 可重复 | deque或list封闭头端开口，不用vector的原因可能是减少扩容开销 |
| queue | deque/list | 尾部插入、头部删除O(1) | 无序 | 可重复 | deque或list封闭头端开口，不用vector的原因可能是减少扩容开销 |
| priority_queue | vector+maxheap | 插入/删除 O(log2n) | 有序 | 可重复 | vector容器+heap处理规则 |
| set | 红黑树 | 插入/删除/查找 O(log2n) | 有序 | 不可重复 |  |
| multiset | 红黑树 | 插入/删除/查找 O(log2n) | 有序 | 可重复 |  |
| map | 红黑树 | 插入/删除/查找 O(log2n) | 有序 | 不可重复 |  |
| multimap | 红黑树 | 插入/删除/查找 O(log2n) | 有序 | 可重复 |  |
| hash_set | 哈希表 | 插入、删除、查找 O(1) <br/> 最差O(n) | 无序 | 不可重复 |  |
| hash_multiset | 哈希表 | 插入、删除、查找 O(1) <br/> 最差O(n) | 无序 | 可重复 |  |
| hash_map | 哈希表 | 插入、删除、查找 O(1) <br/> 最差O(n) | 无序 | 不可重复 |  |
| hash_multimap | 哈希表 | 插入、删除、查找 O(1) <br/> 最差O(n) | 无序 | 可重复 |  |

#### 组成
1. **容器**，一般分为 有序容器和无序容器
2. 迭代器
3. **泛型算法**（针对迭代器）
4. 适配器
5. 分配器（allocator）
6. 仿函数