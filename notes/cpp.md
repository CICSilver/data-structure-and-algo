### C ---- C++ 部分特性添加/升级
#### 命名空间
- 作用：防止命名冲突（如多人协作开发）
- 注意：可嵌套定义， 命名空间冲突时会进行合并
- C在这一问题的处理上使用了static关键字控制变量/函数的存储域
- **命名空间内只能声明函数，不能定义**

#### const
- 在C中，const会将被修饰变量变为只读变量（不可直接修改，但可间接修改）
- 在C++中，编译器严格检查const的对等性，这一特性使const修饰的变量可以直接被当作常量（因为无法使用非const指针来间接修改被修饰变量）
- 修饰函数形参：保护实参不被在函数执行过程中修改  (函数接口的安全性)
- 修饰成员函数：该成员函数只能访问成员变量，不能修改；
- mutable用于声明变量，被其修饰的变量可以被const修饰的函数修改；
- const修饰对象：该对象为常对象，只能访问const成员；(定义并初始化:类必须含有有参构造函数)

#### constexpr
- 用于修饰函数，较之C中的define更安全
- 该关键字用于定义常量表达式，在编译时进行替换，省去了运行时的函数调用、传参、执行、释放等操作，可提高运行效率

#### 函数重载
- 规则：参数个数不通，参数类型不通，参数顺序不同（全部命中即一个重载函数）
- 注：**默认参数会影响重载条件**

#### 引用
- 对一个变量起别名，对其引用做操作就相当于对其本身做操作（这一特性类似于指针，但引用更方便，无需考虑地址和值的问题，因为她只是一个别名）
- **引用是占内存的，相当于一个定义时即绑定初始化地址的指针，且其存储于系统级空间，用户/程序无权操作**
- C++11起提出了右值引用，表示不可写且不可取地址的变量的引用（常用于移动构造函数），自此引用不再只有一级
- 高效编程，是引用这一概念提出的原因；有了引用后，程序员不再需要纠结于传值还是传地址的问题，只要需要修改传入变量，就可以传入该变量的引用；
- 引用的另一个优点：效率高，相较于传值，省去了形参的复制操作，开销更小，大多数情况下直接传引用即可

#### string
- c++中的字符串容器，包含一系列字符串操作，对比于C中的char *，其拥有动态的存储容量与更多的字符串操作，自由度与易用程度更高了
- 因为是容器，所以支持所有迭代器的泛型算法（存在于< algorithm >中）
- **string的可变长设计**，基本类似于java中ArrayList的动态分配机制，每当长度等于容量时，扩容1.5倍/2倍（具体扩容策略不同，结果也不同）
- **千万要注意的一点是**，若有一个指向string对象的指针/引用/迭代器，则在string对象**大小改变后**可能**失效**，因为若string所在内存块的剩余大小不够扩容，则其起始地址会发生变化，之前的所有指针/引用/迭代器都会失效；
- string在初始化时会有默认预留空间，通常为15字节；可以用reserve改变预留空间的大小(但不可小于默认大小)，若赋值后发现预留空间过大，可调用shrink_to_fit方法进行缩容，缩容后的容量等于该字符串的长度
- 访问方式支持下标访问和at()访问，前者边界不安全但开销更小（无需调用函数，省去很多相关开销）

#### 类--结构体
- C++引入类是为了解决变量的访问权限问题；通常在使用一个C库时会碰到的问题就是，函数太多，让用户无从下手，而 C+\+引入这一概念后，类设计者可以将辅助函数进行私有化，使其对用户不可见（C中同样可以使用static来解决可见性问题）
- 在C++中类与结构体的唯一区别就在于其默认权限不同，类的默认权限是私有的，结构体相反

#### 类--对象
- 对象即实例化后的类， 每个对象的成员变量存储与其独占的存储空间，所有同类对象共享方法代码段
- **当某一成员变量被static修饰后，其也会被置于共享空间内**
- **当某一成员函数被static修饰后，同样属于类，所以不会在调用时传入this指针(不存在所属对象)**
- 未被static修饰的成员方法在调用时会被重构，形参中会出现其所有者的指针this
- 访问形式：对象.静态成员  ------ 类名::静态成员（不用实例化）
- 注：static修饰的成员必须在类外初始化

#### 强制类型转换
- static_cast	:相关类型，void*--->任意指针, 父类与子类
- const_cast	:去除指针/引用的const	(用到的情况下通常需要考虑整体的设计问题)
- reinterpret_cast:任意指针之间的类型转换 **(不同于static_cast, 它是任意指针之间.static_cast是任意与void *之间)**
- dynamic_cast	: RTTI(run time type info)多态

#### 构造函数
- C++中用构造函数来代替初始化函数，优点在于对象实例化时可以自动调用，避免了程序员忘记初始化导致的错误；**缺点：调用时机固定**
- 构造函数可以使用初始化列表，对于一些诸如 const、引用、无默认构造函数 的成员对象的需要同时定义且初始化的成员，需要用初始化列表进行初始化;**优先使用初始化列表，效率高**
- 构造函数共有5中，分别是
	- 有参构造函数
	- 无参构造函数
	- 类型转换（记得用explicit防止隐式类型转换）
	- 拷贝构造函数（最好自定义，默认使用浅拷贝**可能导致二次释放**）
	- 移动构造函数
- 其中，移动构造函数常声明为 Foo(Foo &&foo)；，这种构造函数用于将临时对象直接改名为新对象，减少了将临时对象拷贝到新对象时的多余开销，直接将临时对象改名为了新对象
- 若要调用移动构造函数，需要在传参时用std::move函数将参数转换为右值引用
